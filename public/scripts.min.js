function Winwheel(t, e) {
  defaultOptions = {
    canvasId: "canvas",
    centerX: null,
    centerY: null,
    outerRadius: null,
    innerRadius: 0,
    numSegments: 1,
    drawMode: "code",
    rotationAngle: 0,
    textFontFamily: "Arial",
    textFontSize: 4,
    textFontWeight: "bold",
    textOrientation: "horizontal",
    textAlignment: "center",
    textDirection: "normal",
    textMargin: null,
    textFillStyle: "white",
    textStrokeStyle: null,
    textLineWidth: 1,
    fillStyle: "silver",
    strokeStyle: "",
    lineWidth: 1,
    clearTheCanvas: !0,
    imageOverlay: !1,
    drawText: !0,
    pointerAngle: 0,
    wheelImage: null,
    imageDirection: "N",
    responsive: !1,
    scaleFactor: 1,
  };
  for (let e in defaultOptions)
    null != t && void 0 !== t[e]
      ? (this[e] = t[e])
      : (this[e] = defaultOptions[e]);
  if (null != t) for (let e in t) void 0 === this[e] && (this[e] = t[e]);
  this.canvasId
    ? ((this.canvas = document.getElementById(this.canvasId)),
      this.canvas
        ? (null == this.centerX && (this.centerX = this.canvas.width / 2),
          null == this.centerY && (this.centerY = this.canvas.height / 2),
          null == this.outerRadius &&
            (this.canvas.width < this.canvas.height
              ? (this.outerRadius = this.canvas.width / 2 - this.lineWidth)
              : (this.outerRadius = this.canvas.height / 2 - this.lineWidth)),
          (this.ctx = this.canvas.getContext("2d")))
        : ((this.canvas = null), (this.ctx = null)))
    : ((this.canvas = null), (this.ctx = null)),
    (this.segments = new Array(null));
  for (let e = 1; e <= this.numSegments; e++)
    null != t && t.segments && void 0 !== t.segments[e - 1]
      ? (this.segments[e] = new Segment(t.segments[e - 1]))
      : (this.segments[e] = new Segment());
  if (
    (this.updateSegmentSizes(),
    null === this.textMargin && (this.textMargin = this.textFontSize / 1.7),
    null != t && t.animation && void 0 !== t.animation
      ? (this.animation = new Animation(t.animation))
      : (this.animation = new Animation()),
    null != t && t.pins && void 0 !== t.pins && (this.pins = new Pin(t.pins)),
    "image" == this.drawMode || "segmentImage" == this.drawMode
      ? (void 0 === t.fillStyle && (this.fillStyle = null),
        void 0 === t.strokeStyle && (this.strokeStyle = "red"),
        void 0 === t.drawText && (this.drawText = !1),
        void 0 === t.lineWidth && (this.lineWidth = 1),
        void 0 === e && (e = !1))
      : void 0 === e && (e = !0),
    null != t && t.pointerGuide && void 0 !== t.pointerGuide
      ? (this.pointerGuide = new PointerGuide(t.pointerGuide))
      : (this.pointerGuide = new PointerGuide()),
    this.responsive &&
      ((winwheelToDrawDuringAnimation = this),
      (this._originalCanvasWidth = this.canvas.width),
      (this._originalCanvasHeight = this.canvas.height),
      (this._responsiveScaleHeight = this.canvas.dataset.responsivescaleheight),
      (this._responsiveMinWidth = this.canvas.dataset.responsiveminwidth),
      (this._responsiveMinHeight = this.canvas.dataset.responsiveminheight),
      (this._responsiveMargin = this.canvas.dataset.responsivemargin),
      window.addEventListener("load", winwheelResize),
      window.addEventListener("resize", winwheelResize)),
    1 == e)
  )
    this.draw(this.clearTheCanvas);
  else if ("segmentImage" == this.drawMode) {
    (winwheelToDrawDuringAnimation = this), (winhweelAlreadyDrawn = !1);
    for (let t = 1; t <= this.numSegments; t++)
      null !== this.segments[t].image &&
        ((this.segments[t].imgData = new Image()),
        (this.segments[t].imgData.onload = winwheelLoadedImage),
        (this.segments[t].imgData.src = this.segments[t].image));
  }
}
function Pin(t) {
  let e = {
    visible: !0,
    number: 36,
    outerRadius: 3,
    fillStyle: "grey",
    strokeStyle: "",
    lineWidth: 1,
    margin: 3,
    responsive: !1,
  };
  for (let i in e)
    null != t && void 0 !== t[i] ? (this[i] = t[i]) : (this[i] = e[i]);
  if (null != t) for (let e in t) void 0 === this[e] && (this[e] = t[e]);
}
function Animation(t) {
  let e = {
    type: "spinOngoing",
    direction: "clockwise",
    propertyName: null,
    propertyValue: null,
    duration: 10,
    yoyo: !1,
    repeat: null,
    easing: null,
    stopAngle: null,
    spins: null,
    clearTheCanvas: null,
    callbackFinished: null,
    callbackBefore: null,
    callbackAfter: null,
    callbackSound: null,
    soundTrigger: "segment",
  };
  for (let i in e)
    null != t && void 0 !== t[i] ? (this[i] = t[i]) : (this[i] = e[i]);
  if (null != t) for (let e in t) void 0 === this[e] && (this[e] = t[e]);
}
function Segment(t) {
  let e = {
    size: null,
    text: "",
    fillStyle: null,
    strokeStyle: null,
    lineWidth: null,
    textFontFamily: null,
    textFontSize: null,
    textFontWeight: null,
    textOrientation: null,
    textAlignment: null,
    textDirection: null,
    textMargin: null,
    textFillStyle: null,
    textStrokeStyle: null,
    textLineWidth: null,
    image: null,
    imageDirection: null,
    imgData: null,
  };
  for (let i in e)
    null != t && void 0 !== t[i] ? (this[i] = t[i]) : (this[i] = e[i]);
  if (null != t) for (let e in t) void 0 === this[e] && (this[e] = t[e]);
  (this.startAngle = 0), (this.endAngle = 0);
}
function PointerGuide(t) {
  let e = { display: !1, strokeStyle: "red", lineWidth: 3 };
  for (let i in e)
    null != t && void 0 !== t[i] ? (this[i] = t[i]) : (this[i] = e[i]);
}
function winwheelPercentToDegrees(t) {
  let e = 0;
  if (t > 0 && t <= 100) {
    let i = t / 100;
    e = 360 * i;
  }
  return e;
}
function winwheelAnimationLoop() {
  if (winwheelToDrawDuringAnimation) {
    0 != winwheelToDrawDuringAnimation.animation.clearTheCanvas &&
      winwheelToDrawDuringAnimation.ctx.clearRect(
        0,
        0,
        winwheelToDrawDuringAnimation.canvas.width,
        winwheelToDrawDuringAnimation.canvas.height
      );
    let callbackBefore = winwheelToDrawDuringAnimation.animation.callbackBefore,
      callbackAfter = winwheelToDrawDuringAnimation.animation.callbackAfter;
    null != callbackBefore &&
      ("function" == typeof callbackBefore
        ? callbackBefore()
        : eval(callbackBefore)),
      winwheelToDrawDuringAnimation.draw(!1),
      null != callbackAfter &&
        ("function" == typeof callbackAfter
          ? callbackAfter()
          : eval(callbackAfter)),
      winwheelToDrawDuringAnimation.animation.callbackSound &&
        winwheelTriggerSound();
  }
}
function winwheelTriggerSound() {
  0 ==
    winwheelToDrawDuringAnimation.hasOwnProperty("_lastSoundTriggerNumber") &&
    (winwheelToDrawDuringAnimation._lastSoundTriggerNumber = 0);
  let callbackSound = winwheelToDrawDuringAnimation.animation.callbackSound,
    currentTriggerNumber = 0;
  (currentTriggerNumber =
    "pin" == winwheelToDrawDuringAnimation.animation.soundTrigger
      ? winwheelToDrawDuringAnimation.getCurrentPinNumber()
      : winwheelToDrawDuringAnimation.getIndicatedSegmentNumber()),
    currentTriggerNumber !=
      winwheelToDrawDuringAnimation._lastSoundTriggerNumber &&
      ("function" == typeof callbackSound
        ? callbackSound()
        : eval(callbackSound),
      (winwheelToDrawDuringAnimation._lastSoundTriggerNumber =
        currentTriggerNumber));
}
function winwheelStopAnimation(canCallback) {
  if (0 != canCallback) {
    let callback = winwheelToDrawDuringAnimation.animation.callbackFinished;
    null != callback &&
      ("function" == typeof callback
        ? callback(winwheelToDrawDuringAnimation.getIndicatedSegment())
        : eval(callback));
  }
}
function winwheelLoadedImage() {
  if (0 == winhweelAlreadyDrawn) {
    let t = 0;
    for (let e = 1; e <= winwheelToDrawDuringAnimation.numSegments; e++)
      null != winwheelToDrawDuringAnimation.segments[e].imgData &&
        winwheelToDrawDuringAnimation.segments[e].imgData.height &&
        t++;
    t == winwheelToDrawDuringAnimation.numSegments &&
      ((winhweelAlreadyDrawn = !0), winwheelToDrawDuringAnimation.draw());
  }
}
function winwheelResize() {
  let t = 40;
  void 0 !== winwheelToDrawDuringAnimation._responsiveMargin &&
    (t = winwheelToDrawDuringAnimation._responsiveMargin);
  let e = window.innerWidth - t,
    i = winwheelToDrawDuringAnimation._responsiveMinWidth,
    n = winwheelToDrawDuringAnimation._responsiveMinHeight;
  e < i
    ? (e = i)
    : e > winwheelToDrawDuringAnimation._originalCanvasWidth &&
      (e = winwheelToDrawDuringAnimation._originalCanvasWidth);
  let s = e / winwheelToDrawDuringAnimation._originalCanvasWidth;
  if (
    ((winwheelToDrawDuringAnimation.canvas.width =
      winwheelToDrawDuringAnimation._originalCanvasWidth * s),
    winwheelToDrawDuringAnimation._responsiveScaleHeight)
  ) {
    let t = winwheelToDrawDuringAnimation._originalCanvasHeight * s;
    t < n
      ? (t = n)
      : t > winwheelToDrawDuringAnimation._originalCanvasHeight &&
        (t = winwheelToDrawDuringAnimation._originalCanvasHeight),
      (winwheelToDrawDuringAnimation.canvas.height = t);
  }
  (winwheelToDrawDuringAnimation.scaleFactor = s),
    winwheelToDrawDuringAnimation.draw();
}
function chooseWeapon(t) {
  rand = arr[Math.floor(3 * Math.random())];
  let e = document.getElementById("choice");
  (e.innerHTML = `<img src="../img/${t}.png"><img src="../img/${rand}.png">`),
    chooseFate(t, rand);
}
function chooseFate(t, e) {
  if (
    ("rock" === t && "scissors" === e) ||
    ("paper" === t && "rock" === e) ||
    ("scissors" === t && "paper" === e)
  ) {
    let t = document.getElementById("fate");
    (t.innerHTML = "이겼습니다."),
      tallyUp("win"),
      setTimeout(function () {
        foodrand();
      }, 100);
  } else if (
    ("rock" === t && "paper" === e) ||
    ("paper" === t && "scissors" === e) ||
    ("scissors" === t && "rock" === e)
  ) {
    let t = document.getElementById("fate");
    (t.innerHTML = "졌습니다."), tallyUp("lose");
  } else {
    let t = document.getElementById("fate");
    (t.innerHTML = "비겼습니다."), tallyUp("tie");
  }
  $(".gbtn").attr("disabled", !0), $(".rbtn").attr("disabled", !1);
}
function foodrand() {
  (rand = food[Math.floor(10 * Math.random())]),
    1 == confirm(`오늘의 점심은 ${rand} 입니다! \n메뉴를 저장 하시겠습니까?`) &&
      (foodSave.push(rand),
      $.ajax({
        url: "/foodsave/foodsave",
        method: "POST",
        data: { food: rand },
        success: function (t) {
          alert("저장된 메뉴는 마이페이지에 확인하실 수 있습니다.");
        },
        error: function (t) {
          alert("저장하려면 로그인이 필요합니다.");
        },
      }));
}
function tallyUp(t) {
  if ("win" === t) {
    let t = document.getElementById("wins");
    t.innerHTML = wins += 1;
  } else if ("lose" === t) {
    let t = document.getElementById("losses");
    t.innerHTML = losses += 1;
  } else {
    let t = document.getElementById("ties");
    t.innerHTML = ties += 1;
  }
}
function onKoreaShoot() {
  Math.random() < korea.percent
    ? (screen("고지방팀 : " + krTeam[0] + "선수가 슛에 성공했습니다."),
      updateKorScore())
    : screen("고지방팀 : " + krTeam[0] + " 선수가 슛에 실패했습니다.");
  var t = $("#kr-number");
  soccerGame.krScoreNumber--,
    t.html(soccerGame.krScoreNumber),
    disabledKrButton(!0),
    disabledJpButton(!1),
    $(".btn-reset").attr("disabled", !0);
}
function onJapenShoot() {
  krTeam.shift(),
    Math.random() < japen.percent
      ? (screen("저지방팀이 슛에 성공했습니다."), updateJpScore())
      : screen("저지방팀이 슛에 실패했습니다.");
  var t = $("#jp-number");
  soccerGame.jpScoreNumber--,
    t.html(soccerGame.jpScoreNumber),
    disabledKrButton(!1),
    disabledJpButton(!0),
    0 === soccerGame.jpScoreNumber &&
      (korea.score > japen.score
        ? (screen("고지방팀이 승리했습니다."),
          setTimeout(function () {
            foodrand();
          }, 100),
          $(".btn-reset").attr("disabled", !1))
        : korea.score < japen.score
        ? (screen("저지방팀이 승리했습니다."),
          $(".btn-reset").attr("disabled", !1))
        : (screen("비겼습니다."), $(".btn-reset").attr("disabled", !1)),
      disabledKrButton(!0),
      disabledJpButton(!0));
}
function screen(t) {
  var e = $("#score-text");
  e.html(t);
}
function updateKorScore() {
  var t = $("#kr-score");
  (korea.score += 1), t.html(korea.score);
}
function updateJpScore() {
  var t = $("#jp-score");
  (japen.score += 1), t.html(japen.score);
}
function disabledKrButton(t) {
  $(".btn-korea").prop("disabled", t);
}
function disabledJpButton(t) {
  $(".btn-japen").prop("disabled", t);
}
function onReset() {
  $(".btn-reset").attr("disabled", !1), $(".btn-korea").attr("disabled", !1);
  var t = $("#jp-score"),
    e = $("#kr-score"),
    i = $("#kr-number"),
    n = $("#jp-number");
  krTeam.push("국수", "김치찌개", "돈까스", "백반", "파스타"),
    (japen.score = 0),
    (korea.score = 0),
    t.html(japen.score),
    e.html(korea.score),
    (soccerGame.krScoreNumber = 5),
    (soccerGame.jpScoreNumber = 5),
    n.html(soccerGame.jpScoreNumber),
    i.html(soccerGame.krScoreNumber);
}
function alertPrize(t) {
  1 ==
    confirm(
      "오늘의 점심은 " + t.text + "입니다! \n메뉴를 저장 하시겠습니까?"
    ) &&
    (foodSave.push(t.text),
    $.ajax({
      url: "/foodsave/foodsave",
      method: "POST",
      data: { food: t.text },
      success: function (t) {
        alert("저장된 메뉴는 마이페이지에 확인하실 수 있습니다.");
      },
      error: function (t) {
        alert("저장하려면 로그인이 필요합니다.");
      },
    }));
}
function powerSelected(t) {
  0 == wheelSpinning &&
    ((document.getElementById("pw1").className = ""),
    (document.getElementById("pw2").className = ""),
    (document.getElementById("pw3").className = ""),
    t >= 1 && (document.getElementById("pw1").className = "pw1"),
    t >= 2 && (document.getElementById("pw2").className = "pw2"),
    t >= 3 && (document.getElementById("pw3").className = "pw3"),
    (wheelPower = t),
    (document.getElementById("spin_button").src = "./img/spin_on.png"),
    (document.getElementById("spin_button").className = "clickable"));
}
function startSpin() {
  0 == wheelSpinning &&
    (1 == wheelPower
      ? (theWheel.animation.spins = 3)
      : 2 == wheelPower
      ? (theWheel.animation.spins = 8)
      : 3 == wheelPower && (theWheel.animation.spins = 15),
    (document.getElementById("spin_button").src = "../img/spin_off.png"),
    (document.getElementById("spin_button").className = ""),
    theWheel.startAnimation(),
    (wheelSpinning = !0));
}
function resetWheel() {
  theWheel.stopAnimation(!1),
    (theWheel.rotationAngle = 0),
    theWheel.draw(),
    (document.getElementById("pw1").className = ""),
    (document.getElementById("pw2").className = ""),
    (document.getElementById("pw3").className = ""),
    (wheelSpinning = !1);
}
(Winwheel.prototype.updateSegmentSizes = function () {
  if (this.segments) {
    let t = 0,
      e = 0;
    for (let i = 1; i <= this.numSegments; i++)
      null !== this.segments[i].size && ((t += this.segments[i].size), e++);
    let i = 360 - t,
      n = 0;
    i > 0 && (n = i / (this.numSegments - e));
    let s = 0;
    for (let t = 1; t <= this.numSegments; t++)
      (this.segments[t].startAngle = s),
        this.segments[t].size ? (s += this.segments[t].size) : (s += n),
        (this.segments[t].endAngle = s);
  }
}),
  (Winwheel.prototype.clearCanvas = function () {
    this.ctx && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }),
  (Winwheel.prototype.draw = function (t) {
    this.ctx &&
      (void 0 !== t ? 1 == t && this.clearCanvas() : this.clearCanvas(),
      "image" == this.drawMode
        ? (this.drawWheelImage(),
          1 == this.drawText && this.drawSegmentText(),
          1 == this.imageOverlay && this.drawSegments())
        : "segmentImage" == this.drawMode
        ? (this.drawSegmentImages(),
          1 == this.drawText && this.drawSegmentText(),
          1 == this.imageOverlay && this.drawSegments())
        : (this.drawSegments(), 1 == this.drawText && this.drawSegmentText()),
      void 0 !== this.pins && 1 == this.pins.visible && this.drawPins(),
      1 == this.pointerGuide.display && this.drawPointerGuide());
  }),
  (Winwheel.prototype.drawPins = function () {
    if (this.pins && this.pins.number) {
      let t = this.centerX * this.scaleFactor,
        e = this.centerY * this.scaleFactor,
        i = this.outerRadius * this.scaleFactor,
        n = this.pins.outerRadius,
        s = this.pins.margin;
      this.pins.responsive &&
        ((n = this.pins.outerRadius * this.scaleFactor),
        (s = this.pins.margin * this.scaleFactor));
      let a = 360 / this.pins.number;
      for (let l = 1; l <= this.pins.number; l++)
        this.ctx.save(),
          (this.ctx.strokeStyle = this.pins.strokeStyle),
          (this.ctx.lineWidth = this.pins.lineWidth),
          (this.ctx.fillStyle = this.pins.fillStyle),
          this.ctx.translate(t, e),
          this.ctx.rotate(this.degToRad(l * a + this.rotationAngle)),
          this.ctx.translate(-t, -e),
          this.ctx.beginPath(),
          this.ctx.arc(t, e - i + n + s, n, 0, 2 * Math.PI),
          this.pins.fillStyle && this.ctx.fill(),
          this.pins.strokeStyle && this.ctx.stroke(),
          this.ctx.restore();
    }
  }),
  (Winwheel.prototype.drawPointerGuide = function () {
    if (this.ctx) {
      let t = this.centerX * this.scaleFactor,
        e = this.centerY * this.scaleFactor,
        i = this.outerRadius * this.scaleFactor;
      this.ctx.save(),
        this.ctx.translate(t, e),
        this.ctx.rotate(this.degToRad(this.pointerAngle)),
        this.ctx.translate(-t, -e),
        (this.ctx.strokeStyle = this.pointerGuide.strokeStyle),
        (this.ctx.lineWidth = this.pointerGuide.lineWidth),
        this.ctx.beginPath(),
        this.ctx.moveTo(t, e),
        this.ctx.lineTo(t, -i / 4),
        this.ctx.stroke(),
        this.ctx.restore();
    }
  }),
  (Winwheel.prototype.drawWheelImage = function () {
    if (null != this.wheelImage) {
      let t = this.centerX * this.scaleFactor,
        e = this.centerY * this.scaleFactor,
        i = this.wheelImage.width * this.scaleFactor,
        n = this.wheelImage.height * this.scaleFactor,
        s = t - i / 2,
        a = e - n / 2;
      this.ctx.save(),
        this.ctx.translate(t, e),
        this.ctx.rotate(this.degToRad(this.rotationAngle)),
        this.ctx.translate(-t, -e),
        this.ctx.drawImage(this.wheelImage, s, a, i, n),
        this.ctx.restore();
    }
  }),
  (Winwheel.prototype.drawSegmentImages = function () {
    if (this.ctx) {
      let t = this.centerX * this.scaleFactor,
        e = this.centerY * this.scaleFactor;
      if (this.segments)
        for (let i = 1; i <= this.numSegments; i++) {
          let n = this.segments[i];
          if (n.imgData.height) {
            let i = 0,
              s = 0,
              a = 0,
              l = "",
              o = n.imgData.width * this.scaleFactor,
              r = n.imgData.height * this.scaleFactor;
            (l =
              null !== n.imageDirection
                ? n.imageDirection
                : this.imageDirection),
              "S" == l
                ? ((i = t - o / 2),
                  (s = e),
                  (a = n.startAngle + 180 + (n.endAngle - n.startAngle) / 2))
                : "E" == l
                ? ((i = t),
                  (s = e - r / 2),
                  (a = n.startAngle + 270 + (n.endAngle - n.startAngle) / 2))
                : "W" == l
                ? ((i = t - o),
                  (s = e - r / 2),
                  (a = n.startAngle + 90 + (n.endAngle - n.startAngle) / 2))
                : ((i = t - o / 2),
                  (s = e - r),
                  (a = n.startAngle + (n.endAngle - n.startAngle) / 2)),
              this.ctx.save(),
              this.ctx.translate(t, e),
              this.ctx.rotate(this.degToRad(this.rotationAngle + a)),
              this.ctx.translate(-t, -e),
              this.ctx.drawImage(n.imgData, i, s, o, r),
              this.ctx.restore();
          } else console.log("Segment " + i + " imgData is not loaded");
        }
    }
  }),
  (Winwheel.prototype.drawSegments = function () {
    if (this.ctx && this.segments) {
      let t = this.centerX * this.scaleFactor,
        e = this.centerY * this.scaleFactor,
        i = this.innerRadius * this.scaleFactor,
        n = this.outerRadius * this.scaleFactor;
      for (let s = 1; s <= this.numSegments; s++) {
        let a,
          l,
          o,
          r = this.segments[s];
        if (
          ((a = null !== r.fillStyle ? r.fillStyle : this.fillStyle),
          (this.ctx.fillStyle = a),
          (l = null !== r.lineWidth ? r.lineWidth : this.lineWidth),
          (this.ctx.lineWidth = l),
          (o = null !== r.strokeStyle ? r.strokeStyle : this.strokeStyle),
          (this.ctx.strokeStyle = o),
          o || a)
        ) {
          if ((this.ctx.beginPath(), this.innerRadius)) {
            let n =
                Math.cos(
                  this.degToRad(r.startAngle + this.rotationAngle - 90)
                ) *
                (i - l / 2),
              s =
                Math.sin(
                  this.degToRad(r.startAngle + this.rotationAngle - 90)
                ) *
                (i - l / 2);
            this.ctx.moveTo(t + n, e + s);
          } else this.ctx.moveTo(t, e);
          this.ctx.arc(
            t,
            e,
            n,
            this.degToRad(r.startAngle + this.rotationAngle - 90),
            this.degToRad(r.endAngle + this.rotationAngle - 90),
            !1
          ),
            this.innerRadius
              ? this.ctx.arc(
                  t,
                  e,
                  i,
                  this.degToRad(r.endAngle + this.rotationAngle - 90),
                  this.degToRad(r.startAngle + this.rotationAngle - 90),
                  !0
                )
              : this.ctx.lineTo(t, e),
            a && this.ctx.fill(),
            o && this.ctx.stroke();
        }
      }
    }
  }),
  (Winwheel.prototype.drawSegmentText = function () {
    if (this.ctx) {
      let t,
        e,
        i,
        n,
        s,
        a,
        l,
        o,
        r,
        h,
        c = this.centerX * this.scaleFactor,
        m = this.centerY * this.scaleFactor,
        g = this.outerRadius * this.scaleFactor,
        u = this.innerRadius * this.scaleFactor;
      for (let d = 1; d <= this.numSegments; d++) {
        this.ctx.save();
        let p = this.segments[d];
        if (p.text) {
          (t =
            null !== p.textFontFamily ? p.textFontFamily : this.textFontFamily),
            (e = null !== p.textFontSize ? p.textFontSize : this.textFontSize),
            (i =
              null !== p.textFontWeight
                ? p.textFontWeight
                : this.textFontWeight),
            (n =
              null !== p.textOrientation
                ? p.textOrientation
                : this.textOrientation),
            (s =
              null !== p.textAlignment ? p.textAlignment : this.textAlignment),
            (a =
              null !== p.textDirection ? p.textDirection : this.textDirection),
            (l = null !== p.textMargin ? p.textMargin : this.textMargin),
            (o =
              null !== p.textFillStyle ? p.textFillStyle : this.textFillStyle),
            (r =
              null !== p.textStrokeStyle
                ? p.textStrokeStyle
                : this.textStrokeStyle),
            (h =
              null !== p.textLineWidth ? p.textLineWidth : this.textLineWidth),
            (e *= this.scaleFactor),
            (l *= this.scaleFactor);
          let d = "";
          null != i && (d += i + " "),
            null != e && (d += e + "px "),
            null != t && (d += t),
            (this.ctx.font = d),
            (this.ctx.fillStyle = o),
            (this.ctx.strokeStyle = r),
            (this.ctx.lineWidth = h);
          let w = p.text.split("\n"),
            f = 0 - e * (w.length / 2) + e / 2;
          "curved" != n || ("inner" != s && "outer" != s) || (f = 0);
          for (let t = 0; t < w.length; t++) {
            if ("reversed" == a) {
              if ("horizontal" == n) {
                (this.ctx.textAlign =
                  "inner" == s ? "right" : "outer" == s ? "left" : "center"),
                  (this.ctx.textBaseline = "middle");
                let e = this.degToRad(
                  p.endAngle -
                    (p.endAngle - p.startAngle) / 2 +
                    this.rotationAngle -
                    90 -
                    180
                );
                this.ctx.save(),
                  this.ctx.translate(c, m),
                  this.ctx.rotate(e),
                  this.ctx.translate(-c, -m),
                  "inner" == s
                    ? (o && this.ctx.fillText(w[t], c - u - l, m + f),
                      r && this.ctx.strokeText(w[t], c - u - l, m + f))
                    : "outer" == s
                    ? (o && this.ctx.fillText(w[t], c - g + l, m + f),
                      r && this.ctx.strokeText(w[t], c - g + l, m + f))
                    : (o &&
                        this.ctx.fillText(w[t], c - u - (g - u) / 2 - l, m + f),
                      r &&
                        this.ctx.strokeText(
                          w[t],
                          c - u - (g - u) / 2 - l,
                          m + f
                        )),
                  this.ctx.restore();
              } else if ("vertical" == n) {
                (this.ctx.textAlign = "center"),
                  (this.ctx.textBaseline =
                    "inner" == s ? "top" : "outer" == s ? "bottom" : "middle");
                let i = p.endAngle - (p.endAngle - p.startAngle) / 2 - 180;
                (i += this.rotationAngle),
                  this.ctx.save(),
                  this.ctx.translate(c, m),
                  this.ctx.rotate(this.degToRad(i)),
                  this.ctx.translate(-c, -m);
                let n = 0;
                "outer" == s
                  ? (n = m + g - l)
                  : "inner" == s && (n = m + u + l);
                let a = e - e / 9;
                if ("outer" == s)
                  for (let e = w[t].length - 1; e >= 0; e--) {
                    let i = w[t].charAt(e);
                    o && this.ctx.fillText(i, c + f, n),
                      r && this.ctx.strokeText(i, c + f, n),
                      (n -= a);
                  }
                else if ("inner" == s)
                  for (let e = 0; e < w[t].length; e++) {
                    let i = w[t].charAt(e);
                    o && this.ctx.fillText(i, c + f, n),
                      r && this.ctx.strokeText(i, c + f, n),
                      (n += a);
                  }
                else if ("center" == s) {
                  let e = 0;
                  w[t].length > 1 && (e = (a * (w[t].length - 1)) / 2);
                  let i = m + u + (g - u) / 2 + e + l;
                  for (let e = w[t].length - 1; e >= 0; e--) {
                    let n = w[t].charAt(e);
                    o && this.ctx.fillText(n, c + f, i),
                      r && this.ctx.strokeText(n, c + f, i),
                      (i -= a);
                  }
                }
                this.ctx.restore();
              } else if ("curved" == n) {
                let i = 0;
                "inner" == s
                  ? ((i = u + l), (this.ctx.textBaseline = "top"))
                  : "outer" == s
                  ? ((i = g - l),
                    (this.ctx.textBaseline = "bottom"),
                    (i -= e * (w.length - 1)))
                  : "center" == s &&
                    ((i = u + l + (g - u) / 2),
                    (this.ctx.textBaseline = "middle"));
                let n = 0,
                  a = 0;
                if (w[t].length > 1) {
                  (this.ctx.textAlign = "left"), (n = (e / 10) * 4);
                  let s = 100 / i;
                  n *= s;
                  let l = n * w[t].length;
                  a = p.startAngle + ((p.endAngle - p.startAngle) / 2 - l / 2);
                } else
                  (a = p.startAngle + (p.endAngle - p.startAngle) / 2),
                    (this.ctx.textAlign = "center");
                (a += this.rotationAngle), (a -= 180);
                for (let e = w[t].length; e >= 0; e--) {
                  this.ctx.save();
                  let s = w[t].charAt(e);
                  this.ctx.translate(c, m),
                    this.ctx.rotate(this.degToRad(a)),
                    this.ctx.translate(-c, -m),
                    r && this.ctx.strokeText(s, c, m + i + f),
                    o && this.ctx.fillText(s, c, m + i + f),
                    (a += n),
                    this.ctx.restore();
                }
              }
            } else if ("horizontal" == n) {
              (this.ctx.textAlign =
                "inner" == s ? "left" : "outer" == s ? "right" : "center"),
                (this.ctx.textBaseline = "middle");
              let e = this.degToRad(
                p.endAngle -
                  (p.endAngle - p.startAngle) / 2 +
                  this.rotationAngle -
                  90
              );
              this.ctx.save(),
                this.ctx.translate(c, m),
                this.ctx.rotate(e),
                this.ctx.translate(-c, -m),
                "inner" == s
                  ? (o && this.ctx.fillText(w[t], c + u + l, m + f),
                    r && this.ctx.strokeText(w[t], c + u + l, m + f))
                  : "outer" == s
                  ? (o && this.ctx.fillText(w[t], c + g - l, m + f),
                    r && this.ctx.strokeText(w[t], c + g - l, m + f))
                  : (o &&
                      this.ctx.fillText(w[t], c + u + (g - u) / 2 + l, m + f),
                    r &&
                      this.ctx.strokeText(
                        w[t],
                        c + u + (g - u) / 2 + l,
                        m + f
                      )),
                this.ctx.restore();
            } else if ("vertical" == n) {
              (this.ctx.textAlign = "center"),
                (this.ctx.textBaseline =
                  "inner" == s ? "bottom" : "outer" == s ? "top" : "middle");
              let i = p.endAngle - (p.endAngle - p.startAngle) / 2;
              (i += this.rotationAngle),
                this.ctx.save(),
                this.ctx.translate(c, m),
                this.ctx.rotate(this.degToRad(i)),
                this.ctx.translate(-c, -m);
              let n = 0;
              "outer" == s ? (n = m - g + l) : "inner" == s && (n = m - u - l);
              let a = e - e / 9;
              if ("outer" == s)
                for (let e = 0; e < w[t].length; e++) {
                  let i = w[t].charAt(e);
                  o && this.ctx.fillText(i, c + f, n),
                    r && this.ctx.strokeText(i, c + f, n),
                    (n += a);
                }
              else if ("inner" == s)
                for (let e = w[t].length - 1; e >= 0; e--) {
                  let i = w[t].charAt(e);
                  o && this.ctx.fillText(i, c + f, n),
                    r && this.ctx.strokeText(i, c + f, n),
                    (n -= a);
                }
              else if ("center" == s) {
                let e = 0;
                w[t].length > 1 && (e = (a * (w[t].length - 1)) / 2);
                let i = m - u - (g - u) / 2 - e - l;
                for (let e = 0; e < w[t].length; e++) {
                  let n = w[t].charAt(e);
                  o && this.ctx.fillText(n, c + f, i),
                    r && this.ctx.strokeText(n, c + f, i),
                    (i += a);
                }
              }
              this.ctx.restore();
            } else if ("curved" == n) {
              let i = 0;
              "inner" == s
                ? ((i = u + l),
                  (this.ctx.textBaseline = "bottom"),
                  (i += e * (w.length - 1)))
                : "outer" == s
                ? ((i = g - l), (this.ctx.textBaseline = "top"))
                : "center" == s &&
                  ((i = u + l + (g - u) / 2),
                  (this.ctx.textBaseline = "middle"));
              let n = 0,
                a = 0;
              if (w[t].length > 1) {
                (this.ctx.textAlign = "left"), (n = (e / 10) * 4);
                let s = 100 / i;
                n *= s;
                let l = n * w[t].length;
                a = p.startAngle + ((p.endAngle - p.startAngle) / 2 - l / 2);
              } else
                (a = p.startAngle + (p.endAngle - p.startAngle) / 2),
                  (this.ctx.textAlign = "center");
              a += this.rotationAngle;
              for (let e = 0; e < w[t].length; e++) {
                this.ctx.save();
                let s = w[t].charAt(e);
                this.ctx.translate(c, m),
                  this.ctx.rotate(this.degToRad(a)),
                  this.ctx.translate(-c, -m),
                  r && this.ctx.strokeText(s, c, m - i + f),
                  o && this.ctx.fillText(s, c, m - i + f),
                  (a += n),
                  this.ctx.restore();
              }
            }
            f += e;
          }
        }
        this.ctx.restore();
      }
    }
  }),
  (Winwheel.prototype.degToRad = function (t) {
    return 0.017453292519943295 * t;
  }),
  (Winwheel.prototype.setCenter = function (t, e) {
    (this.centerX = t), (this.centerY = e);
  }),
  (Winwheel.prototype.addSegment = function (t, e) {
    let i,
      n = new Segment(t);
    if ((this.numSegments++, void 0 !== e)) {
      for (let t = this.numSegments; t > e; t--)
        this.segments[t] = this.segments[t - 1];
      (this.segments[e] = n), (i = e);
    } else (this.segments[this.numSegments] = n), (i = this.numSegments);
    return this.updateSegmentSizes(), this.segments[i];
  }),
  (Winwheel.prototype.setCanvasId = function (t) {
    t
      ? ((this.canvasId = t),
        (this.canvas = document.getElementById(this.canvasId)),
        this.canvas && (this.ctx = this.canvas.getContext("2d")))
      : ((this.canvasId = null), (this.ctx = null), (this.canvas = null));
  }),
  (Winwheel.prototype.deleteSegment = function (t) {
    if (this.numSegments > 1) {
      if (void 0 !== t)
        for (let e = t; e < this.numSegments; e++)
          this.segments[e] = this.segments[e + 1];
      (this.segments[this.numSegments] = void 0),
        this.numSegments--,
        this.updateSegmentSizes();
    }
  }),
  (Winwheel.prototype.windowToCanvas = function (t, e) {
    let i = this.canvas.getBoundingClientRect();
    return {
      x: Math.floor(t - i.left * (this.canvas.width / i.width)),
      y: Math.floor(e - i.top * (this.canvas.height / i.height)),
    };
  }),
  (Winwheel.prototype.getSegmentAt = function (t, e) {
    let i = null,
      n = this.getSegmentNumberAt(t, e);
    return null !== n && (i = this.segments[n]), i;
  }),
  (Winwheel.prototype.getSegmentNumberAt = function (t, e) {
    let i,
      n,
      s,
      a,
      l,
      o = this.windowToCanvas(t, e),
      r = this.centerX * this.scaleFactor,
      h = this.centerY * this.scaleFactor,
      c = this.outerRadius * this.scaleFactor,
      m = this.innerRadius * this.scaleFactor;
    o.x > r ? ((s = o.x - r), (n = "R")) : ((s = r - o.x), (n = "L")),
      o.y > h ? ((a = o.y - h), (i = "B")) : ((a = h - o.y), (i = "T"));
    let g = a / s,
      u = (180 * Math.atan(g)) / Math.PI,
      d = 0;
    if (
      ((l = Math.sqrt(a * a + s * s)),
      "T" == i && "R" == n
        ? (d = Math.round(90 - u))
        : "B" == i && "R" == n
        ? (d = Math.round(u + 90))
        : "B" == i && "L" == n
        ? (d = Math.round(90 - u + 180))
        : "T" == i && "L" == n && (d = Math.round(u + 270)),
      0 != this.rotationAngle)
    ) {
      let t = this.getRotationPosition();
      (d -= t), d < 0 && (d = 360 - Math.abs(d));
    }
    let p = null;
    for (let t = 1; t <= this.numSegments; t++)
      if (
        d >= this.segments[t].startAngle &&
        d <= this.segments[t].endAngle &&
        l >= m &&
        l <= c
      ) {
        p = t;
        break;
      }
    return p;
  }),
  (Winwheel.prototype.getIndicatedSegment = function () {
    let t = this.getIndicatedSegmentNumber();
    return this.segments[t];
  }),
  (Winwheel.prototype.getIndicatedSegmentNumber = function () {
    let t = 0,
      e = this.getRotationPosition(),
      i = Math.floor(this.pointerAngle - e);
    i < 0 && (i = 360 - Math.abs(i));
    for (let e = 1; e < this.segments.length; e++)
      if (i >= this.segments[e].startAngle && i <= this.segments[e].endAngle) {
        t = e;
        break;
      }
    return t;
  }),
  (Winwheel.prototype.getCurrentPinNumber = function () {
    let t = 0;
    if (this.pins) {
      let e = this.getRotationPosition(),
        i = Math.floor(this.pointerAngle - e);
      i < 0 && (i = 360 - Math.abs(i));
      let n = 360 / this.pins.number,
        s = 0;
      for (let e = 0; e < this.pins.number; e++) {
        if (i >= s && i <= s + n) {
          t = e;
          break;
        }
        s += n;
      }
      "clockwise" == this.animation.direction &&
        (t++, t > this.pins.number && (t = 0));
    }
    return t;
  }),
  (Winwheel.prototype.getRotationPosition = function () {
    let t = this.rotationAngle;
    if (t >= 0) {
      if (t > 360) {
        let e = Math.floor(t / 360);
        t -= 360 * e;
      }
    } else {
      if (t < -360) {
        let e = Math.ceil(t / 360);
        t -= 360 * e;
      }
      t = 360 + t;
    }
    return t;
  }),
  (Winwheel.prototype.startAnimation = function () {
    if (this.animation) {
      this.computeAnimation(), (winwheelToDrawDuringAnimation = this);
      let t = new Array(null);
      (t[this.animation.propertyName] = this.animation.propertyValue),
        (t.yoyo = this.animation.yoyo),
        (t.repeat = this.animation.repeat),
        (t.ease = this.animation.easing),
        (t.onUpdate = winwheelAnimationLoop),
        (t.onComplete = winwheelStopAnimation),
        (this.tween = TweenMax.to(this, this.animation.duration, t));
    }
  }),
  (Winwheel.prototype.stopAnimation = function (t) {
    winwheelToDrawDuringAnimation &&
      (winwheelToDrawDuringAnimation.tween &&
        winwheelToDrawDuringAnimation.tween.kill(),
      winwheelStopAnimation(t)),
      (winwheelToDrawDuringAnimation = this);
  }),
  (Winwheel.prototype.pauseAnimation = function () {
    this.tween && this.tween.pause();
  }),
  (Winwheel.prototype.resumeAnimation = function () {
    this.tween && this.tween.play();
  }),
  (Winwheel.prototype.computeAnimation = function () {
    this.animation &&
      ("spinOngoing" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = -1),
          null == this.animation.easing &&
            (this.animation.easing = "Linear.easeNone"),
          null == this.animation.yoyo && (this.animation.yoyo = !1),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction &&
            (this.animation.propertyValue = 0 - this.animation.propertyValue))
        : "spinToStop" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = 0),
          null == this.animation.easing &&
            (this.animation.easing = "Power3.easeOut"),
          null == this.animation.stopAngle
            ? (this.animation._stopAngle = Math.floor(359 * Math.random()))
            : (this.animation._stopAngle =
                360 - this.animation.stopAngle + this.pointerAngle),
          null == this.animation.yoyo && (this.animation.yoyo = !1),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction
            ? ((this.animation.propertyValue =
                0 - this.animation.propertyValue),
              (this.animation.propertyValue -= 360 - this.animation._stopAngle))
            : (this.animation.propertyValue += this.animation._stopAngle))
        : "spinAndBack" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = 1),
          null == this.animation.easing &&
            (this.animation.easing = "Power2.easeInOut"),
          null == this.animation.yoyo && (this.animation.yoyo = !0),
          null == this.animation.stopAngle
            ? (this.animation._stopAngle = 0)
            : (this.animation._stopAngle = 360 - this.animation.stopAngle),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction
            ? ((this.animation.propertyValue =
                0 - this.animation.propertyValue),
              (this.animation.propertyValue -= 360 - this.animation._stopAngle))
            : (this.animation.propertyValue += this.animation._stopAngle))
        : this.animation.type);
  }),
  (Winwheel.prototype.getRandomForSegment = function (t) {
    let e = 0;
    if (t)
      if (void 0 !== this.segments[t]) {
        let i = this.segments[t].startAngle,
          n = this.segments[t].endAngle,
          s = n - i - 2;
        s > 0
          ? (e = i + 1 + Math.floor(Math.random() * s))
          : console.log(
              "Segment size is too small to safely get random angle inside it"
            );
      } else console.log("Segment " + t + " undefined");
    else console.log("Segment number not specified");
    return e;
  }),
  (Segment.prototype.changeImage = function (t, e) {
    (this.image = t),
      (this.imgData = null),
      e && (this.imageDirection = e),
      (winhweelAlreadyDrawn = !1),
      (this.imgData = new Image()),
      (this.imgData.onload = winwheelLoadedImage),
      (this.imgData.src = this.image);
  });
let winwheelToDrawDuringAnimation = null,
  winhweelAlreadyDrawn = !1;
$(function () {
  var t = $(".next-btn"),
    e = $(".prev-btn"),
    i = $(".top-btn"),
    n = $(".bot-btn"),
    s = $(".prev-bot"),
    a = $(".prev-top"),
    l = $("article .si-z"),
    o = 0,
    r = 1;
  t.on("click", function () {
    var t = l.eq(o),
      e = l.eq(r);
    t.css({ left: 0 }).stop().animate({ left: "-100%" }),
      e.css({ left: "100%" }).stop().animate({ left: 0 }),
      (r += 1),
      console.log(r);
  }),
    e.on("click", function () {
      r -= 1;
      var t = l.eq(o),
        e = l.eq(r);
      t.css({ left: "100%" }).stop().animate({ left: 0 }),
        e.css({ left: 0 }).stop().animate({ left: "100%" }),
        console.log(r);
    }),
    i.on("click", function () {
      r += 1;
      var t = l.eq(o),
        e = l.eq(r);
      t.css({ left: 0 }).stop().animate({ left: "-100%" }),
        e
          .css({ left: "100%", top: "-100%" })
          .stop()
          .animate({ left: 0, top: 0 }),
        $(".prev-btn").css("display", "none"),
        $(".prev-top").css("display", "block"),
        console.log(r);
    }),
    n.on("click", function () {
      r += 2;
      var t = l.eq(o),
        e = l.eq(r);
      t.css({ left: 0 }).stop().animate({ left: "-100%" }),
        e
          .css({ left: "100%", bottom: "-100%" })
          .stop()
          .animate({ left: 0, bottom: 0 }),
        $(".prev-btn").css("display", "none"),
        $(".prev-bot").css("display", "block"),
        console.log(r);
    }),
    a.on("click", function () {
      o += 3;
      var t = l.eq(o);
      t.css({ left: 0, top: 0 }).stop().animate({ left: "100%", top: "100%" }),
        (r = 2),
        (o = 0),
        $(".prev-btn").css("display", "block");
    }),
    s.on("click", function () {
      $(".prev-btn").css("display", "block"), (o += 4);
      var t = l.eq(o);
      t
        .css({ left: 0, bottom: 0 })
        .stop()
        .animate({ left: "100%", bottom: "100%" }),
        (r = 2),
        (o = 0);
    }),
    $("#login").click(function () {
      $("#login-wrap").fadeIn(), $("#login-content").animate({ top: "30%" });
    }),
    $(".close").click(function () {
      $("#login-wrap").fadeOut(), $("#login-content").animate({ top: "0" });
    }),
    $("html").click(function (t) {
      "login-wrap" === t.target.id &&
        ($("#login-wrap").fadeOut(), $("#login-content").animate({ top: "0" }));
    }),
    $("#join").click(function () {
      $("#join-wrap").fadeIn(), $("#join-content").animate({ top: "30%" });
    }),
    $(".close").click(function () {
      $("#join-wrap").fadeOut(), $("#join-content").animate({ top: "0" });
    }),
    $("html").click(function (t) {
      "join-wrap" === t.target.id &&
        ($("#join-wrap").fadeOut(), $("#join-content").animate({ top: "0" }));
    });
});
const arr = ["rock", "paper", "scissors"];
let food = [
    "김치찌개",
    "된장찌개",
    "불고기",
    "뼈해장국",
    "짬뽕",
    "짜장면",
    "백반",
    "파스타",
    "볶음밥",
    "돈까스",
  ],
  foodSave = [],
  rand = "",
  wins = 0,
  losses = 0,
  ties = 0;
$(".rbtn").click(function () {
  $(".gbtn").attr("disabled", !1), $(".rbtn").attr("disabled", !0);
});
var korea = { score: 0, percent: 0.7 },
  japen = { score: 0, percent: 0.7 },
  soccerGame = { jpScoreNumber: 5, krScoreNumber: 5 },
  krTeam = ["국수", "김치찌개", "돈까스", "백반", "파스타"];
let theWheel = new Winwheel({
    numSegments: 12,
    outerRadius: 212,
    textFontSize: 20,
    segments: [
      { fillStyle: "#3f297e", text: "된장찌개" },
      { fillStyle: "#1d61ac", text: "불고기" },
      { fillStyle: "#169ed8", text: "김치볶음밥" },
      { fillStyle: "#209b6c", text: "짬뽕" },
      { fillStyle: "#60b236", text: "순대국" },
      { fillStyle: "#efe61f", text: "생선구이" },
      { fillStyle: "#f7a416", text: "스파게티" },
      { fillStyle: "#e6471d", text: "비빔밥" },
      { fillStyle: "#e5177b", text: "어제먹은거" },
      { fillStyle: "#be107f", text: "돈카츠" },
      { fillStyle: "#881f7e", text: "라면" },
      { fillStyle: "#dc0936", text: "냉면" },
    ],
    animation: {
      type: "spinToStop",
      duration: 15,
      spins: 9,
      callbackFinished: alertPrize,
      soundTrigger: "pin",
    },
    pins: { number: 16 },
  }),
  wheelPower = 0,
  wheelSpinning = !1;
